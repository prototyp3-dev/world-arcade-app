/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import { Signer, ethers, ContractReceipt } from "ethers";
import Ajv, { ValidateFunction } from "ajv"
import addFormats from "ajv-formats"

import { 
    advanceInput, inspect, 
    AdvanceOutput, InspectOptions, AdvanceInputOptions,
    Report as CartesiReport, Notice as CartesiNotice, Voucher as CartesiVoucher, 
    Maybe, Proof, validateNoticeFromParams, wasVoucherExecutedFromParams, executeVoucherFromParams, 
    queryNotice, queryReport, queryVoucher, GraphqlOptions
} from "cartesi-client";

/**
 * Configs
 */

const ajv = new Ajv();
addFormats(ajv);
ajv.addFormat("biginteger", (data) => {
    const dataTovalidate = data.startsWith('-') ? data.substring(1) : data;
    return ethers.utils.isHexString(dataTovalidate) && dataTovalidate.length % 2 == 0;
});
const abiCoder = new ethers.utils.AbiCoder();
export const CONVENTIONAL_TYPES: Array<string> = ["bytes","hex","str","int","dict","list","tuple","json"];
const MAX_SPLITTABLE_OUTPUT_SIZE = 4194247;


/**
 * Models
 */

export enum IOType {
    report,
    notice,
    voucher,
    mutationPayload,
    queryPayload
}

interface ModelInterface<T> {
    ioType: IOType;
    abiTypes: Array<string>;
    params: Array<string>;
    decoder?(data: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport): T;
    exporter?(data: T): string;
    validator: ValidateFunction<T>;
}

export interface Models {
    [key: string]: ModelInterface<any>;
}

export interface InspectReportInput {
    index?: number;
}

export interface InspectReport {
    payload: string;
    input?: InspectReportInput;
    index?: number;
}

export interface OutputGetters {
    [key: string]: (o?: GraphqlOptions) => Promise<CartesiReport>|Promise<CartesiNotice>|Promise<CartesiVoucher>;
}

export const outputGetters: OutputGetters = {
    report: queryReport,
    notice: queryNotice,
    voucher: queryVoucher
}

export interface MutationOptions extends AdvanceInputOptions {
    decode?: boolean;
}

export interface QueryOptions extends InspectOptions {
    decode?: boolean;
    decodeModel?: string;
}

export class IOData<T extends object> {
    [key: string]: any;
    _model: ModelInterface<T>

    constructor(model: ModelInterface<T>, data: T, validate: boolean = true) {
        this._model = model;
        for (const key of this._model.params) {
            this[key] = (data as any)[key];
        }
        if (validate) this.validate();
    }

    get = (): T => {
        const data: any = {};
        for (const key of this._model.params) {
            data[key] = this[key];
        }
        return data;
    }

    validate = (): boolean => {
        const dataToValidate: any = { ...this.get() };
        for (const k of Object.keys(dataToValidate)) {
            if (ethers.BigNumber.isBigNumber(dataToValidate[k]))
                dataToValidate[k] = dataToValidate[k].toHexString();
        }
        if (!this._model.validator(dataToValidate))
            throw new Error(`Data does not implement interface: ${ajv.errorsText(this._model.validator.errors)}`);     
        return true;
    }

    export(excludeParams: string[] = []): string {
        let payload: string;
        switch(this._model.ioType) {
            case IOType.mutationPayload: {
                // parametrize input to url
                const inputData: any = this.get();
                const paramList = Array<any>();
                for (const key of this._model.params) {
                    paramList.push(inputData[key]);
                }
                payload = abiCoder.encode(this._model.abiTypes,paramList);
                break;
            }
            case IOType.queryPayload: {
                // parametrize input to url
                const inputData: T = this.get();
                const paramList = Array<string>();
                for (const key in inputData) {
                    if (inputData[key] == undefined) continue;
                    if (excludeParams.indexOf(key) > -1) continue;
                    if (Array.isArray(inputData[key])) {
                        for (const element in inputData[key]) {
                            paramList.push(`${key}=${inputData[key][element]}`);
                        }
                    } else {
                        paramList.push(`${key}=${inputData[key]}`);
                    }
                }
                payload = paramList.length > 0 ? `?${paramList.join('&')}` : "";
                break;
            }
            default: {
                throw new Error(`Invalid payload type ${this._model.ioType}`);
                // break;
            }
        }
        return payload;
    }
}

export class BasicOutput<T extends object> extends IOData<T> {
    _payload: string
    _inputIndex?: number
    _outputIndex?: number

    constructor(model: ModelInterface<T>, payload: string, inputIndex?: number, outputIndex?: number) {
        super(model,genericDecodeTo<T>(payload,model),false);
        this._inputIndex = inputIndex;
        this._outputIndex = outputIndex;
        this._payload = payload;
    }
}

export class Output<T extends object> extends BasicOutput<T>{
    constructor(model: ModelInterface<T>, report: CartesiReport | InspectReport) {
        super(model, report.payload, report.input?.index, report.index);
    }
}

export class OutputWithProof<T extends object> extends BasicOutput<T>{
    _proof: Maybe<Proof> | undefined
    _inputIndex: number
    _outputIndex: number
    
    constructor(model: ModelInterface<T>, payload: string, inputIndex: number, outputIndex: number, proof: Maybe<Proof> | undefined) {
        super(model, payload, inputIndex, outputIndex);
        this._inputIndex = inputIndex;
        this._outputIndex = outputIndex;
        this._proof = proof;
    }
}

export class Event<T extends object> extends OutputWithProof<T>{
    constructor(model: ModelInterface<T>, notice: CartesiNotice) {
        super(model, notice.payload, notice.input.index, notice.index, notice.proof);
    }
    validateOnchain = async (signer: Signer, dappAddress: string): Promise<boolean> => {
        if (this._proof == undefined)
            throw new Error("Notice has no proof");
        return await validateNoticeFromParams(signer,dappAddress,this._payload,this._proof);
    }
}

export class ContractCall<T extends object> extends OutputWithProof<T>{
    _destination: string
    constructor(model: ModelInterface<T>, voucher: CartesiVoucher) {
        super(model, voucher.payload, voucher.input.index, voucher.index, voucher.proof);
        this._destination = voucher.destination;
    }
    wasExecuted = async (signer: Signer, dappAddress: string): Promise<boolean> => {
        return await wasVoucherExecutedFromParams(signer,dappAddress,this._inputIndex,this._outputIndex);
    }
    execute = async (signer: Signer, dappAddress: string): Promise<ContractReceipt | null> => {
        if (this._proof == undefined)
            throw new Error("Voucher has no proof");
        return await executeVoucherFromParams(signer,dappAddress,this._destination,this._payload,this._proof);
    }
}


/*
 * Helpers
 */

// Advance
export async function genericAdvanceInput<T extends object>(
    client:Signer,
    dappAddress:string,
    selector:string,
    inputData: IOData<T>,
    options?:AdvanceInputOptions
):Promise<AdvanceOutput|ContractReceipt> {
    if (options == undefined) options = {};

    const payloadHex = inputData.export();
    const output = await advanceInput(client,dappAddress,selector + payloadHex.replace('0x',''),options).catch(
        e => {
            if (String(e.message).startsWith('0x'))
                throw new Error(ethers.utils.toUtf8String(e.message));
            throw new Error(e.message);
    });

    return output;
}

// Inspect
export async function inspectCall(
    payload:string,
    options:InspectOptions
):Promise<InspectReport> {
    options.decodeTo = "no-decode";
    const inspectResult: string = await inspect(payload,options).catch(
        e => {
            if (String(e.message).startsWith('0x'))
                throw new Error(ethers.utils.toUtf8String(e.message));
            throw new Error(e.message);
    }) as string; // hex string
    return {payload:inspectResult};
}

export async function genericInspect<T extends object>(
    inputData: IOData<T>,
    route: string,
    options?:InspectOptions
):Promise<InspectReport> {
    if (options == undefined) options = {};
    options.aggregate = true;
    const excludeParams: string[] = [];
    const matchRoute = route.matchAll(/\{(\w+)\}/g);
    for (const m of matchRoute) {
        route.replace(m[0],inputData[m[0]]);
        excludeParams.push(m[1]);
    }
    const payload = `${route}${inputData.export()}`
    return await inspectCall(payload,options);
}

// Decode
export function genericDecodeTo<T extends object>(data: string,model: ModelInterface<T>): T {
    let dataObj: any;
    switch(model.ioType) {
        /*# case mutationPayload: {
            break;
        }
        case queryPayload: {
            break;
        }*/
        case IOType.report: {
            const dataStr = ethers.utils.toUtf8String(data);
            try {
                dataObj = JSON.parse(dataStr);
            } catch(e) {
                throw new Error(dataStr);
            }
            dataObj = JSON.parse(ethers.utils.toUtf8String(data));
            if (!model.validator(dataObj))
                throw new Error(`Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`);     
            break;
        }
        case IOType.notice: {
            const dataValues = abiCoder.decode(model.abiTypes,data);
            dataObj = {};
            let ind = 0;
            for (const key of model.params) {
                dataObj[key] = dataValues[ind];
                ind++;
            }
            const dataToValidate = { ...dataObj };
            for (const k of Object.keys(dataToValidate)) {
                if (ethers.BigNumber.isBigNumber(dataToValidate[k]))
                    dataToValidate[k] = dataToValidate[k].toHexString();
            }
            if (!model.validator(dataToValidate))
                throw new Error(`Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`);     
            
            break;
        }
        case IOType.voucher: {
            const abiTypes: Array<string> = ["bytes4"].concat(model.abiTypes);
            const dataValues = abiCoder.decode(abiTypes,data);
            dataObj = {};
            let ind = 0;
            for (const key of model.params) {
                if (ind == 0) continue; // skip selector
                dataObj[key] = dataValues[ind-1];
                ind++;
            }
            const dataToValidate = { ...dataObj };
            for (const k of Object.keys(dataToValidate)) {
                if (ethers.BigNumber.isBigNumber(dataToValidate[k]))
                    dataToValidate[k] = dataToValidate[k].toHexString();
            }
            if (!model.validator(dataToValidate))
                throw new Error(`Data does not implement interface: ${ajv.errorsText(model.validator.errors)}`);
            break;
        }
        default: {
            throw new Error(`Cannot convert ${model.ioType}`);
            // break;
        }
    }
    return dataObj;
}

export function decodeToConventionalTypes(data: string,modelName: string): any {
    if (!CONVENTIONAL_TYPES.includes(modelName))
        throw new Error(`Cannot decode to ${modelName}`);
    switch(modelName) {
        case "bytes": {
            if (typeof data == "string") {
                if (ethers.utils.isHexString(data))
                    return ethers.utils.arrayify(data);
                else
                    throw new Error(`Cannot decode to bytes`);
            }
            return data;
        }
        case "hex": {
            return data;
        }
        case "str": {
            return ethers.utils.toUtf8String(data);
        }
        case "int": {
            if (typeof data == "string") {
                if (ethers.utils.isHexString(data))
                    return parseInt(data, 16);
                else
                    throw new Error(`Cannot decode to int`);
            }
            if (ethers.utils.isBytes(data))
                return parseInt(ethers.utils.hexlify(data), 16);
            else
                throw new Error(`Cannot decode to int`);
        }
        case "dict": case "list": case "tuple": case "json": {
            return JSON.parse(ethers.utils.toUtf8String(data));
        }
    }
}
